# 第 7 章 封装

## 7.1 封装记录（Encapsulate Record）

### 动机

- 数据不变，简单的记录型结构更好
- 对于可变数据，类对象可以隐藏结构的细节、用户不必追究存储的细节和计算过程、重新命名字段并同时提供新老字段名的访问方法
- 一条记录在大范围中使用，“数据结构不直观”这个问题会造成很多困扰。可以重构它，使其变得更直观，但是不如使用类


### 做法

- 对持有记录的变量使用封装变量，将其封装到一个函数中
- 创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。然后在类上定义一个访问函数，用于返回原始的记录。修改封装变量的函数，令其使用这个访问函数。
- 新建一个函数，让它返回该类的对象，而非那条原始的记录。
- 对于该记录的每处使用点，将原先返回记录的函数调用替换为那个返回实例对象的函数调用。使用对象上的访问函数来获取数据的字段，如果该字段的访问函数还不存在，那就创建一个。每次更改之后运行测试。
- 如果该记录比较复杂，例如是个嵌套解构，那么先重点关注客户端对数据的更新操作，对于读取操作可以考虑返回一个数据副本或只读的数据代理。
- 移除类对原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除。

## 7.2 封装集合（Encapsulate Collection）

### 动机

- 封装可变数据可以很容易看清楚数据被修改的地点和修改方式，更改数据结构更方便
- 面对对象开发者对封装尤为重视，但值对集合变量的访问进行封装，依然让取值函数返回集合本身，使得集合的成员变量可以直接被修改。为避免此种情况，在类上提供一些修改集合的方法，使其对集合的修改必须经过类
- 作者给出两种方法，一种避免直接修改集合的方法是，永远不直接返回集合的值。还有一种方法是，以某种形式限制集合的访问权，只允许对集合进行读操作，类似方法：将构造出的集合建立在迭代器或枚举对象的基础上，因为迭代器也不能修改它迭代的集合。
- 采用哪种方法并无定式，最重要的是在同个代码库中做法要保持一致。我建议只用一种方案，这样每个人都能很快习惯它，并在每次调用集合的访问函数时期望相同的行为。

### 做法

- 如果集合的引用尚未被封装起来，先用封装变量封装它。
- 在类上添加用于“添加集合元素”和“移除集合元素”的函数。
- 如果存在对该集合的设值函数，尽可能先用移除设值函数移除它。如果不能移除该设值函数，至少让它返回集合的一份副本。
- 查找集合的引用点。如果有调用者直接修改集合，令该处调用使用新的添加/移除元素的函数。每次修改后执行测试。
- 修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或数据副本。

## 7.3 以对象取代基本类型（Replace Primitive with Object）

### 动机

- 开发初期，你往往决定以简单的数据项表示简单的情况，比如使用数字或字符串等。但随着开发的进行，你可能会发现，这些简单数据项不再那么简单了。比如说，一开始你可能会用一个字符串来表示“电话号码”的概念，但是随后它又需要“格式化”“抽取区号”之类的特殊行为。这类逻辑很快便会占领代码库，制造出许多重复代码，增加使用时的成本。
- 一旦发现对某个数据的操作不仅仅局限于打印时，就会为它创建一个新类。
- 开始这个类也许只是简单包装一下简单类型的数据，不过只要类有了，日后添加的业务逻辑就有地可去了。这些小小的封装值开始可能价值甚微，但只要悉心照料，它们很快便能成长为有用的工具。
- 创建新类无须太大的工作量，但我发现它们往往对代码库有深远的影响。实际上，许多经验丰富的开发者认为，这是他们的工具箱里最实用的重构手法之一——尽管其价值常为新手程序员所低估。

### 做法

- 如果变量尚未被封装起来，先用封装变量封装它。
- 为这个数据值创建一个简单的类。类的构造函数应该保存这个数据值，并为它提供一个取值函数。
- 修改第一步得到的设值函数，令其创建一个新类的对象并将其存入字段，如果有必要的话，同时修改字段的类型声明。
- 修改取值函数，令其调用新类的取值函数，并返回结果。
- 考虑对第一步得到的访问函数使用函数改名，以便更好反映其用途。
- 考虑应用将引用对象改为值对象或将值对象改为引用对象，明确指出新对象的角色是值对象还是引用对象。

## 7.4 以查询取代临时变量（Replace Temp with Query）

### 动机

- 尽管使用变量很方便，很多时候还是值得更进一步，将它们抽取成函数。
- 将变量抽取到函数中在分解冗长的函数时过程更简单，因为不需要将变量作为参数传递给提炼出来的小函数。将变量的计算逻辑放到函数中，有助于在提炼的得到的函数与原函数之间设立清晰的边界，发现并避免难缠的依赖和副作用。
- 改用函数还让我避免了在多个函数中重复编写计算逻辑。这项重构手法在类中施展效果最好，因为类为待提炼函数提供了一个共同的上下文。如果不是在类中，我很可能会在顶层函数中拥有过多参数，这将冲淡提炼函数所能带来的诸多好处。
- 以查询取代临时变量手法只适用于处理某些类型的临时变量：那些只被计算一次且之后不再被修改的变量。最简单的情况是，这个临时变量只被赋值一次，但在更复杂的代码片段里，变量也可能被多次赋值——此时应该将这些计算代码一并提炼到查询函数中。并且，待提炼的逻辑多次计算同样的变量时，应该能得到相同的结果。

### 做法

- 检查变量在使用前是否已经完全计算完毕，检查计算它的那段代码是否每次都能得到一样的值。
- 如果变量目前不是只读的，但是可以改造成只读变量，那就先改造它。
- 将为变量赋值的代码段提炼成函数。
- 如果变量和函数不能使用同样的名字，那么先为函数取个临时的名字。
- 确保待提炼函数没有副作用。若有，先应用将查询函数和修改函数分离手法隔离副作用。
- 应用内联变量手法移除临时变量

## 7.5 提炼类（Extract Class）

- 一个类应该是一个清晰的抽象，只处理一些明确的责任，等等。但是在实际工作中，类会不断成长扩展。
- 当有一个维护大量函数和数据的类。这样的类因为太大而不易理解。此时需要考虑哪些部分可以分离出去，并将它们分离到一个独立的类中。如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示应该将他们分离出去。一个有用的测试就是问自己，如果搬移了某些字段和函数，会发生什么事？其他字段和函数是否因此变得无意义？
- 另一个往往在开发后期出现的信号是类的子类化方式。如果发现子类化只影响类的部分特性，或如果发现某些特性需要以一种方式来子类化，某些特性则需要以另一种方式子类化，这就意味着需要分解原来的类。

### 做法

- 决定如何分解类所负的责任。
- 创建一个新的类，用以表现从旧类中分离出来的责任。
- 如果旧类剩下的责任与旧类的名称不符，为旧类改名。
- 构造旧类时创建一个新类的实例，建立“从旧类访问新类”的连接关系。
- 对于想搬移的每一个字段，运用搬移字段搬移之。每次更改后运行测试。
- 使用搬移函数将必要函数搬移到新类。先搬移较低层函数（也就是“被其他函数调用”多于“调用其他函数”者）。每次更改后运行测试。
- 检查两个类的接口，去掉不再需要的函数，必要时为函数重新取一个适合新环境的名字。
- 决定是否公开新的类。如果确实需要，考虑对新类应用将引用对象改为值对象使其成为一个值对象。

## 7.6 内联类（Inline Class）

### 动机

- 内联类正好与提炼类相反。
- 如果一个类不再承担足够责任，不再有单独存在的理由（这通常是因为此前的重构动作移走了这个类的责任），就会挑选这一“萎缩类”的最频繁用户（也是一个类），以本手法将“萎缩类”塞进另一个类中。
- 应用这个手法的另一个场景是，我手头有两个类，想重新安排它们肩负的职责，并让它们产生关联。先用本手法将它们内联成一个类再用提炼类去分离其职责会更加简单。
- 这是重新组织代码时常用的做法：有时把相关元素一口气搬移到位更简单，但有时先用内联手法合并各自的上下文，再使用提炼手法再次分离它们会更合适。

### 做法

- 对于待内联类（源类）中的所有 public 函数，在目标类上创建一个对应的函数，新创建的所有函数应该直接委托至源类。
- 修改源类 public 方法的所有引用点，令它们调用目标类对应的委托方法。每次更改后运行测试。
- 将源类中的函数与数据全部搬移到目标类，每次修改之后进行测试，直到源类变成空壳为止。
- 删除源类，为它举行一个简单的 “葬礼”。

## 7.7 隐藏委托关系（Hide Delegate）

### 动机

- 一个好的模块化的设计，“封装”即使不是其最关键特征，也是最关键特征之一。“封装”意味着每个模块都应该尽可能少了解系统的其他部分。如此一来，一旦发生变化，需要了解这一变化的模块就会比较少——这会使变化比较容易进行。
- 当我们初学面向对象技术时就被教导，封装意味着应该隐藏自己的字段
- 如果某些客户端先通过服务对象的字段得到另一个对象（受托类），然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一受托类修改了接口，变化会波及通过服务对象使用它的所有客户端。我可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖。这么一来，即使将来委托关系发生变化，变化也只会影响服务对象，而不会直接波及所有客户端。

### 做法

- 对于每个委托关系中的函数，在服务对象端建立一个简单的委托函数。
- 调整客户端，令它只调用服务对象提供的函数。每次调整后运行测试。
- 如果将来不再有任何客户端需要取用 Delegate（受托类），便可移除服务对象中的相关访问函数。

## 7.8 移除中间人（Remove Middle Man）

### 动机

- 在隐藏委托关系的“动机”一节中，我谈到了“封装受托对象”的好处。但是这层封装也是有代价的。每当客户端要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受托类的特性（功能）越来越多，更多的转发函数就会使人烦躁。服务类完全变成了一个中间人，此时就应该让客户直接调用受托类。（这个味道通常在人们狂热地遵循迪米特法则时悄然出现。我总觉得，如果这条法则当初叫作“偶尔有用的迪米特建议”，如今能少很多烦恼。）
- 很难说什么程度的隐藏才是合适的。还好，有了隐藏委托关系（189）和删除中间人，我大可不必操心这个问题，因为我可以在系统运行过程中不断进行调整。随着代码的变化，“合适的隐藏程度”这个尺度也相应改变。6 个月前恰如其分的封装，现今可能就显得笨拙。重构的意义就在于：你永远不必说对不起——只要把出问题的地方修补好就行了。
#### 迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。英文简写为: LOD。


### 做法

- 为受托对象创建一个取值函数。
- 对于每个委托函数，让其客户端转为连续的访问函数调用。每次替换后运行测试。
- 替换完委托方法的所有调用点后，你就可以删掉这个委托方法了。
- 这能通过可自动化的重构手法来完成，你可以先对受托字段使用封装变量，再应用内联函数内联所有使用它的函数。

## 7.9 替换算法（Substitute Algorithm）

### 动机

- 如果我发现做一件事可以有更清晰的方式，我就会用比较清晰的方式取代复杂的方式。算法即是如此。“重构”可以把一些复杂的东西分解为较简单的小块，但有时就必须壮士断腕，删掉整个算法，代之以较简单的算法。随着对问题有了更多理解，往往会发现，在原先的做法之外，有更简单的解决方案，此时就需要改变原先的算法。如果开始使用程序库，而其中提供的某些功能/特性与我自己的代码重复，那么也需要改变原先的算法。
- 有时会想修改原先的算法，让它去做一件与原先略有差异的事。这时候可以先把原先的算法替换为一个较易修改的算法，这样后续的修改会轻松许多。
- 使用这项重构手法之前，我得确定自己已经尽可能分解了原先的函数。替换一个巨大且复杂的算法是非常困难的，只有先将它分解为较简单的小型函数，我才能很有把握地进行算法替换工作。

### 做法

- 整理一下待替换的算法，保证它已经被抽取到一个独立的函数中。
- 先只为这个函数准备测试，以便固定它的行为。
- 准备好另一个（替换用）算法。
- 运行测试，比对新旧算法的运行结果。如果测试通过，那就大功告成；否则，在后续测试和调试过程中，以旧算法为比较参照标准。
