# 第 6 章 第一组重构

## 6.1 提炼函数（Extract Function）

### 动机（不同意见）

- 从代码的长度考虑，认为一个函数应该能在一屏中显示
- 从复用的角度考虑，认为只要被用过不止一次的代码，就应该单独放进一个函数，只用过一次的代码则保持内联（inline）的状态
- 将意图与实现分开，看代码时不需要关心函数如何达成其用途（作者动机）

在一个大函数中，一段代码的顶上放着一句注释，说明这段代码要做什么。在把这段代码提炼到自己的函数中时，这样的注释往往会提示一个好名字。

### 做法

- 创造一个新函数，根据这个函数的意图来对它命名（以它“做什么”来命名，而不是以它“怎样做”命名）
- 将待提炼的代码从源函数复制到新建的目标函数中
- 仔细检查提炼出的代码，看看其中是否引用了作用域限于源函数、在提炼出的新函数中访问不到的变量。若是，以参数的形式将它们传递给新函数
- 在源函数中，将被提炼代码段替换为对目标函数的调用

## 6.2 内联函数（Inline Function）

### 动机

- 函数内部代码和函数名称本就清晰易读
- 间接性可能带来帮助，但非必要的间接性总是让人不舒服

### 做法

- 检查函数，确定它不具多态性
- 找出这个函数的所有调用点
- 将这个函数的所有调用点都替换为函数本体
- 删除该函数的定义

## 6.3 提炼变量（Extract Variable）

### 动机

- 将表达式分解为比较容易管理的形式
- 使用局部变量给代码中的一部分进行命名

### 做法

- 确认要提炼的表达式没有副作用
- 声明一个不可修改的变量，把你想要提炼的表达式复制一份，以该表达式的结果值给这个变量赋值
- 用这个新变量取代原来的表达式

## 6.4 内联变量（Inline Variable）

### 动机

- 有时，变量名并不比表达式本身更具表现力，可能会妨碍重构附近的代码

### 做法

- 检查确认变量赋值语句的右侧表达式没有副作用
- 如果变量没有被声明为不可修改，先将其变为不可修改，并进行测试
- 找到使用该变量的地方，将其替换为直接使用赋值语句的右侧表达式

## 6.5 改变函数声明（Change Function Declaration）

别名：函数改名（Rename Function）

曾用名：函数改名（Rename Method）

曾用名：添加参数（Add Parameter）

曾用名：移除参数（Remove Parameter）

别名：修改签名（Change Signature）

- 一个好名字能让我一眼看出函数的用途，而不必查看其实现代码
- 函数的参数列表阐述了函数如何与外部世界共处

## 6.6 封装变量（Encapsulate Variable）

### 动机

- 搬移一处被广泛使用的数据，最好的办法往往是先以函数形式封装所有对该数据的访问（先不动源数据），就能把“重新组织数据”的困难任务转化为“重新组织函数”这个相对简单的任务

### 做法

- 创建封装函数，在其中访问和更新变量值
- 执行静态检查
- 逐一修改使用该变量的代码，将其改为调用合适的封装函数。每次替换之后，执行测试
- 限制变量的可见性

## 6.7 变量改名（Rename Variable）(无代码)

## 6.8 引入参数对象（Introduce Parameter Object）

### 动机

- 用数据结构代替“数据泥团”
- 可以使用名字来访问参数中的元素，提升代码一致性
- 催生代码中更深层次的改变，将数据结构提升为新的抽象概念，创建除围绕这些抽象概念的公用行为等

### 做法

- 创建一个合适的数据结构（对象或类）
- 测试
- 使用改变函数声明给原来的函数新增一个参数，类型是新建的数据结构
- 测试
- 调整所有调用者，传入新数据结构的适当实例。每修改一处，执行测试
- 用新数据结构中的每项元素，逐一取代参数列表中与之对应的参数项，然后删除原来的参数。测试

## 6.9 函数组合成类（Combine Functions into Class）

### 动机

- 一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数），是时候组建一个类了
- 类给函数一个明确的执行环境，简化调用，方便和其他方法共享参数

### 做法

- 公共数据封装进类中
- 对于使用/处理该数据的每个函数，将其移入新类中

## 6.10 函数组合成变换（Combine Functions into Transform）

### 动机

- 经常需要把数据“喂”给一个程序，让它再计算出各种派生信息
- 派生数值可能会在几个不同地方用到，因此这些计算逻辑也常会在用到派生数据的地方重复
- 把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复

### 做法

- 创建一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值（通常需要对输入的记录做深复制）
- 将一块逻辑移入变换函数中，并返回，替换使用数据的地方
- 测试 重复

